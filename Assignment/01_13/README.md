# Assignment (01/13)

## Mission Object
### Assignment 1. unsigned char (8bit) 변수의 값을 비트단위로 찍어주기
- 지역변수에 특정 값을 하나 넣음
- 비트 단위로 분해해서 `0` 이면 `0` 출력, `1` 이면 `1` 출력

### Assignment 2. unsigned short (16bit) 변수의 각 비트를 컨트롤 하기
- `unsigned short 변수 = 0` 으로 초기값 가짐.
- 키보드로 `1 ~ 16`의 비트 자리 입력을 받음
- `1 or 0`  을 사용자로부터 받아서 지정된 자리의 비트를 `0` 또는 `1`로 바꿔줌.
- 다른 위치에 입력된 기존 데이터는 보존이 되어야 함

### Assignment 3. unsigned int (32bit) 변수를 바이트 단위로 사용하기
- `unsigned int 변수 = 0` 초기값 가짐
- 키보드로 `1 ~ 4` 의 바이트 위치를 입력 받고
- 해당 위치에 넣을 데이터 `0 ~ 255` 를 입력 받음
- 사용자가 입력한 바이트 위치에 해당 값을 넣음
- 데이터가 입력 되면 바이트 단위로 쪼개서 출력, 4바이트 16진수 출력
- 기존 데이터는 보존이 되어야 하며 입력된 바이트 위치의 데이터는 기존 값을 지우고 넣음.

---

## Retrospect

### Assignment 1
- 마스킹을 위해 만든 변수 `curBit`의 값을 `128(0b10000000)`으로 초기화했어야 했는데 `255(0b11111111)`으로 초기화한 실수가 있었다.
- `while`문 내에서 `curBit`의 값을 갱신하지 않은 실수가 있었다.

### Assignment 2
- 특정 위치의 비트를 **켜기** 위해 `1`을 `shift` 연산한 값과 기존 값을 `or` 연산 하였다.
- 특정 위치의 비트를 **끄기** 위해 `1`을 `shift` 연산한 값에 `비트 not` 연산을 적용하였고, 이 값과 기존 값을 `and` 연산 하였다.

### Assignment 3

- `bytePosition`에 입력할 값에 따라, 비트 연산을 적용할 값(`value` 변수)에 적절히 `shift` 연산을 적용하였다.

- 처음에는 `uint32_t` 자료형 변수에 직접 입력을 받고 `<<` 연산 적용값을 사용하였는데 이 경우 `65535`와 같이 8비트를 넘어가는 값에 대해 프로그램이 올바르게 동작하지 않았다. 이 문제를 해결하기 위해 `uint8_t` 자료형 변수에 입력을 받은 다음 `uint32_t` 변수에 `<<` 연산을 하며 값을 대입하였다.
    - (예 : 1번째 Byte 값을 65535로 입력한 경우 `0x000000ff`가 출력되어야 하는데 `0x0000ffff`가 출력됨.)

- 다른 Byte Zone의 Bit값은 보존되어야 했기 때문에, or 연산에 사용할 값(`value` 변수)의 다른 Byte Zone들의 Bit들은 모두 1로 만들었다.
    - `value = ~(0) & value;`가 해당 역할을 한다.
