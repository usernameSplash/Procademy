# Lab (01/25)

## LAB-1: 구조체 패딩

구조체는 구조체의 멤버 변수들에 따라 자료형의 크기가 결정된다. 하지만 구조체의 크기는 구조체의 멤버 변수들의 크기의 총합과 항상 일치하지는 않는다. 그 이유는 '구조체 패딩' 때문이다.

32bit 체제 기준으로, CPU는 값을 4Byte의 경계에서부터 4Byte씩 잘라서 처리한다. (4Byte의 경계란, 메모리 주소 0부터 시작해서 4씩 격자가 그어져 있다고 생각하면 좋다.)

구조체의 멤버 변수는 순서를 가지기 때문에, 구조체 변수를 만든다면 메모리 상에서도 구조체 내에 선언된 순서대로 각 멤버변수들이 위치하게 된다.

예를 들어, 아래와 같은 구조체가 있다고 가정해보자.

```C
typedef struct MyStruct
{
    char a;
    int b;
} MyStruct_t;
```

`MyStruct_t`형 변수를 만들면 메모리 상에 `a`가 먼저, 그 다음 `b`가 저장된다.

**구조체 변수의 메모리 위치가 정확히 메모리 경계에서 시작한다고 가정하였을 때**, 만약 `a` 다음에 곧바로 `b`가 저장된다면 4Byte 공간 내에서 `char` 자료형 `a`를 위해 1Byte, 그 다음 `int` 자료형 `b`를 위해 3Byte를 할애하고 다음 4Byte 공간의 첫 1Byte가 `b`의 처리를 마저 끝내기 위해 사용될 것이다.

이 경우 `b`에 접근하기 위해서는 CPU가 메모리에 2번 접근해야 하기 때문에 성능상 좋지 않다.

따라서 메모리에 `a` 값 이후에 3Byte를 비워두고, 그 다음 4Byte 공간에 `b`를 온전하게 저장하도록 한다.

따라서 `sizeof(MyStruct_t)`또한 8이다.

### 구조체 패딩 기준

1. 모든 멤버 변수는 자기 자신의 자료형의 경계에 맞춰 메모리에 저장된다.
    - 예: `short`는 2Byte의 경계에, `int`는 4Byte의 경계에, `long long`은 8Byte의 경계에 맞춰진다.
2. 구조체 전체의 크기는 구조체 멤버 중 가장 큰 자료형의 크기의 배수로 떨어진다.
    - 예: 구조체 내에 `long long` 자료형이 있다면 이 구조체의 크기는 8의 배수가 된다.

### 구조체의 마지막 멤버에도 패딩이 붙는 이유

구조체의 마지막 멤버에도 패딩이 붙어 구조체의 크기가 결정된다.

언뜻 생각해보면 구조체의 마지막 멤버 다음에는 다른 멤버가 없고, 구조체 외의 다른 지역 변수 등을 메모리에 저장한다면 그 값들은 각자의 경계에 맞춰서 메모리 공간을 사용하면 될 것 같다.

그러나 구조체의 마지막 멤버에도 패딩이 필요하다. 그 이유는 `구조체 배열` 때문이다.

배열은 같은 자료형의 값들을 메모리 상에서 연속된 공간에 저장한다. 만약 마지막 멤버 뒤에 패딩이 붙지 않는다면, 배열의 두 번째 요소부터는 멤버 변수들의 메모리 경계가 어긋나버릴 것이다.

구조체 배열에서 모든 요소의 메모리 경계가 어긋나지 않게 하기 위해 마지막 멤버에도 패딩이 필요하다.

### 구조체 패딩이 제대로 동작하지 않는 경우

전역 변수의 경우에는 문제가 없다. 하지만 지역 변수로 선언되어있는 경우에는 문제가 있을 수도 있다.

`ebp` 레지스터의 값 자체가 어긋나있는 경우에는 구조체 변수가 올바른 메모리 경계에서부터 저장되지 않는다.

구조체 패딩은, **구조체가 주소 0을 기점으로 선언된 경우**를 전제로 하여 적용된다. 즉, 시작점의 경계는 항상 맞춰져 있다고 가정한 것이다.

따라서 시작점이 맞춰져있다는 보장이 없는 경우에는 구조체 패딩으로 인한 성능상의 이점이 사라지게 된다.

### 구조체 패딩을 적용하지 않는 경우

네트워크 통신 목적으로 사용하는 구조체에는 구조체 패딩을 사용하지 않는다.

그 이유는 다음과 같다.

1. 불필요한 Byte를 없애서 네트워크 트래픽을 낮출 수 있다.
2. 플랫폼별로 구조체 패딩에 대한 규칙이 다를 수 있기 때문이다.

`#pragma pack(1)` 전처리기를 사용하면 변수들을 1Byte 경계로 정렬하겠다는 의미이다. 1Byte 경계로 변수들이 정렬되면 구조체 패딩을 없앨 수 있다. 


## LAB-2: Cache 존재 확인하기

CPU는 메인 메모리에 저장된 값을 처리하기 위해서, 메인 메모리의 값을 레지스터로 불러와야 한다.

성능 향상을 목적으로, 'Cache Memory'라는 CPU에 붙어있는 고속의 메모리 공간을 둔다.

CPU가 메모리로부터 자주 불러올(Load) 값이 있다면, 그 값을 Cache Memory에 저장하여 불러오는 시간을 획기적으로 단축할 수 있다. 

### Cache Hit

CPU는 일단 불러올 값이 Cache Memory에 존재하는지 확인한 후, 없다면 메인 메모리로부터 값을 가져온다.

우선순위에 따라 L1, L2, L3 Cache로 구분되며 L1이 가장 높은 우선순위를 갖는다.

Cache Memory에 CPU가 불러오고자 하는 값이 존재하는 경우를 `Cache Hit`, 존재하지 않는 경우를 `Cache Miss`라고 한다.

최대한 `Cache Hit`가 일어나도록 유도하는 방향으로 작성한 프로그램은 그렇지 않은 프로그램에 비해 최대 20~30배의 속도 향상 효과가 있다고 한다.

### Cache Hit 높이기

CPU는 다음과 같은 기준으로 데이터를 캐시 메모리에 저장하고자 한다.

1. 시간적 지역성 : 최근에 접근한 메모리는 다시 접근될 가능성이 높다. 따라서 최근에 접근한 메모리를  Cache Memory에 저장한다.
2. 공간적 지역성 : 최근에 접근한 메모리와 가까운 주소의 메모리는 다시 접근될 가능성이 높다. 따라서 최근에 접근한 메모리가 속한 `Cache Line`을 Cache Memory에 저장한다.

`LAB_01_25_2`의 `main.cpp` 코드를 보면, `Test1`과 `Test2` 함수가 있다.

둘 다 2차원 배열의 모든 요소를 접근하는 코드인데, `Test1`은 Cache Hit를 적극적으로 사용한 코드이고 `Test2`는 그렇지 않다.

직접 테스트해 본 결과 약 4배 정도의 실행 속도 차이가 있었다.

### Cache Line 존재 확인하기

`LAB_01_25_2`의 `main.cpp` 코드의 `main` 함수를 보면 변수 `a`의 주소에 `0xffffffc0`를 and연산한 주소값을 출력하고 있다.

`0xffffffc0`는 맨 오른쪽의 6개 비트가 0이고 나머지 비트가 모두 1인 수이다.

`Cache Line`은 64Byte씩 나누어져 있으므로 어떤 값이 속한 `Cache Line`의 시작 주소를 찾기 위해서는 하위 6비트를 0으로 만들면 된다.

`main` 함수는 그것을 확인하기 위한 실습 코드이다.